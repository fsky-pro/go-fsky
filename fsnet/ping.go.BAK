/**
@copyright: fantasysky 2016
@website: https://www.fsky.pro
@brief: use ping command to verify the address is valid or not
@author: fanky
@version: 1.0
@date: 2021-03-23
**/

package fsnet

import (
	"bytes"
	"container/list"
	"encoding/binary"
	"fmt"
	"net"
	"os"
	"time"

	"golang.org/x/net/context"
)

type S_PingStatus struct {
	Bytes int   // 接收到字节数
	Seq   int   // 请求次序
	Time  int   // 延时
	Error error // 错误

	EndStatus struct {
		Sends    int // 发送总包数
		Receives int // 接收包数
		Losts    int // 丢失包数
		MinTime  int // 最小响应时间
		MaxTime  int // 最大响应时间
		AVTime   int // 平均响应时间
	}
}

type S_ICMP struct {
	Type        uint8
	Code        uint8
	Checksum    uint16
	Identifier  uint16
	SequenceNum uint16
}

func _checkSum(data []byte) uint16 {
	var (
		sum    uint32
		length int = len(data)
		index  int
	)
	for length > 1 {
		sum += uint32(data[index])<<8 + uint32(data[index+1])
		index += 2
		length -= 2
	}
	if length > 0 {
		sum += uint32(data[index])
	}
	sum += (sum >> 16)
	return uint16(^sum)
}

func _newIcmp() *bytes.Buffer {
	icmp := new(S_ICMP)
	icmp.Type = uint8(8)
	var buffer bytes.Buffer
	binary.Write(&buffer, binary.BigEndian, icmp)
	icmp.Checksum = _checkSum(buffer.Bytes())
	buffer.Reset()
	binary.Write(&buffer, binary.BigEndian, icmp)
	return &buffer
}

func _makeRequest(seq int) []byte {
	pid := os.Getpid() & 0xfff
	p := make([]byte, 64)
	p[0] = 8
	p[1] = 0
	p[2] = 0
	p[3] = 0
	p[4] = uint8(pid >> 8)
	p[5] = uint8(pid & 0xff)
	p[6] = uint8(seq >> 8)
	p[7] = uint8(seq & 0xff)
	cklen := len(p)
	s := uint32(0)
	for i := 0; i < (cklen - 1); i += 2 {
		s += uint32(p[i+1])<<8 | uint32(p[i])
	}
	if cklen&1 == 1 {
		s += uint32(p[cklen-1])
	}
	s = (s >> 16) + (s * 0xffff)
	s = s + (s >> 16)
	p[2] ^= uint8(^s & 0xff)
	p[3] ^= uint8(^s >> 8)
	return p
}

func Ping(ctx context.Context, dst string, interval time.Duration, ch chan *S_PingStatus) error {
	laddr := net.IPAddr{IP: net.ParseIP("0.0.0.0")}
	raddr, err := net.ResolveIPAddr("ip", dst)
	if err != nil {
		return fmt.Errorf("error the remote address: %s", dst)
	}
	conn, err := net.DialIP("ip4:icmp", &laddr, raddr)
	if err != nil {
		return fmt.Errorf("dial to remote ip error: %v", err)
	}

	//buffer := _newIcmp()
	recv := make([]byte, 1024)
	durs := list.New()
	sends := 0
	losts := 0
	go func() {
	L:
		for {
			select {
			case <-ctx.Done():
				defer conn.Close()
				break L
			default:
				status := new(S_PingStatus)
				bs := _makeRequest(sends)
				if _, err := conn.Write(bs); err != nil {
					status.Error = fmt.Errorf("write ping data fail: %v", err)
					ch <- status
					break
				}
				sends++
				start := time.Now()

				conn.SetReadDeadline((time.Now().Add(time.Second * 5)))
				fmt.Println(111111)
				n, err := conn.Read(recv)
				fmt.Println(222222, err.Error())
				if err != nil {
					losts++
					status.Error = fmt.Errorf("time out!")
					break
				}
				end := time.Now()

				dur := end.Sub(start).Nanoseconds() / 1e6
				durs.PushBack(dur)
				status.Bytes = n
				status.Seq = sends
				status.Time = int(dur)
				ch <- status
			}

			time.Sleep(interval)
		}

		var min, max, sum int64
		if durs.Len() == 0 {
			min, max, sum = 0, 0, 0
		} else {
			min = durs.Front().Value.(int64)
			max = min
			sum = 0
		}
		for v := durs.Front(); v != nil; v = v.Next() {
			val := v.Value.(int64)
			switch {
			case val < min:
				min = val
			case val > max:
				max = val
			}
			sum += val
		}

		status := new(S_PingStatus)
		status.EndStatus.Sends = sends
		status.EndStatus.Receives = sends - losts
		status.EndStatus.Losts = losts
		status.EndStatus.MinTime = int(min)
		status.EndStatus.MaxTime = int(max)
		status.EndStatus.AVTime = int(float32(sum) / float32(sends-losts))
		ch <- status

	}()
	return nil
}
